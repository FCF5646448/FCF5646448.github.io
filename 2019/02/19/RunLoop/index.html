<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="runloop,">










<meta name="description" content="RunLoop是内部维护事件循环的一个对象。而事件循环可以不断地对消息或事件进行管理：当没有消息时，会将进程从用户态切到内核态，由此对当前线程进行休眠，以避免资源占用；当有消息需要处理时，会从内核态切到用户态，以便及时唤醒线程。">
<meta name="keywords" content="runloop">
<meta property="og:type" content="article">
<meta property="og:title" content="RunLoop">
<meta property="og:url" content="http://yoursite.com/2019/02/19/RunLoop/index.html">
<meta property="og:site_name" content="FCF Home">
<meta property="og:description" content="RunLoop是内部维护事件循环的一个对象。而事件循环可以不断地对消息或事件进行管理：当没有消息时，会将进程从用户态切到内核态，由此对当前线程进行休眠，以避免资源占用；当有消息需要处理时，会从内核态切到用户态，以便及时唤醒线程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/02/19/RunLoop/RunLoop.png">
<meta property="og:image" content="http://yoursite.com/2019/02/19/RunLoop/runloop.jpeg">
<meta property="og:updated_time" content="2019-02-19T03:41:13.842Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RunLoop">
<meta name="twitter:description" content="RunLoop是内部维护事件循环的一个对象。而事件循环可以不断地对消息或事件进行管理：当没有消息时，会将进程从用户态切到内核态，由此对当前线程进行休眠，以避免资源占用；当有消息需要处理时，会从内核态切到用户态，以便及时唤醒线程。">
<meta name="twitter:image" content="http://yoursite.com/2019/02/19/RunLoop/RunLoop.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/19/RunLoop/">





  <title>RunLoop | FCF Home</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FCF Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/RunLoop/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengCaifan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FCF Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RunLoop</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T11:18:03+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS进阶/" itemprop="url" rel="index">
                    <span itemprop="name">iOS进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  RunLoop是内部维护事件循环的一个对象。而事件循环可以不断地对消息或事件进行管理：当没有消息时，会将进程从用户态切到内核态，由此对当前线程进行休眠，以避免资源占用；当有消息需要处理时，会从内核态切到用户态，以便及时唤醒线程。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/2019/02/19/RunLoop/RunLoop.png" alt=""></p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h4><p>首先，一个函数(包括main函数)在按顺序执行完逻辑代码后就会return，然后函数栈里的资源就会被回收掉。比如C语言的简单main函数，执行return后，程序就结束了。那一个APP，其实也是由main函数入口和结束的程序。如果main函数里什么都不做，跑完会立马回到桌面上。比如iOS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    return 0; //执行完这里就会退回桌面</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那要怎样，我们才能保留App程序的活性呢！很简单，在main函数里添加一个死循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        printf(&quot;xxx&quot;);</span><br><span class="line">    &#125; while (1);</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时候你会发现App程序不会再退出来了，而是一直在消耗CPU和内存，直到iOS系统把它强制杀掉。而RunLoop实际上也是一个类似的运行循环，使iOS应用程序在main函数中保存运行状态，不会退出。</p>
<p>标准答案： <strong>RunLoop是通过内部维护的“事件循环”来对“事件/消息进行管理”的一个对象</strong><br>关键点：<br><strong>事件循环（Event Loop）</strong>：维护的事件循环可以用来不断地处理事件或消息，然后进行管理 ！同时当没有消息需要处理时，会从用户态向内核态进行切换，由此可以进行当前线程的休眠，以避免资源占用；另外当有消息需要处理时，会发生从内核态到用户态的切换，然后当前用户线程就会立即被唤醒。(所以不是上面假设的while循环那么简单)。   有消息需要处理时是<strong>用户态</strong>，没有时是<strong>内核态</strong>。<br>用户态：系统上层应用程序活动的空间。<br>内核态：内核资源，为上层应用提供资源。</p>
<p>Q：什么是RunLoop？<br><strong>RunLoop是内部维护事件循环的一个对象。而事件循环可以不断地对消息或事件进行管理：当没有消息时，会将进程从用户态切到内核态，由此对当前线程进行休眠，以避免资源占用；当有消息需要处理时，会从内核态切到用户态，以便及时唤醒线程。</strong></p>
<p>Q：main函数为什么可以保持不退出？<br><strong>main函数调用的ApplicationMain里启动了主线程的RunLoop运行循环。而RunLoop可以不断地接受和处理消息，同时在用户态和内核态之间进行切换，从而避免资源的占用及休息。所以Main函数不会退出</strong></p>
<h4 id="RunLoop的作用："><a href="#RunLoop的作用：" class="headerlink" title="RunLoop的作用："></a>RunLoop的作用：</h4><ul>
<li>保证程序不退出；</li>
<li>监听事件：网络事件、定时器事件、触摸事件；</li>
<li>定时渲染UI：每个Runloop期间，被标记为需要重绘的UI都会进行重绘；</li>
<li>调节CPU的工作，休息或工作。Runloop各个状态的调整；</li>
</ul>
<h4 id="RunLoop的数据结构"><a href="#RunLoop的数据结构" class="headerlink" title="RunLoop的数据结构"></a>RunLoop的数据结构</h4><p>NSRunLoop是对CFRunLoop的封装。</p>
<ul>
<li>CFRunLoop：内部的数据结构包含了 pthread、modes、currentMode、commonModes、CommonModeItems。 由此可以发现线程和runloop是一个一一对应的关系；modes是一个mode的集合。CommonModeItems包含多个Observer、多个Timer、多个Source。</li>
<li>CFRunLoopMode：数据结构包含了name、sources0、sources1、observers、timers。</li>
<li>CFRunLoopSource：source0、source1；source0需要手动唤醒线程，source1具备唤醒线程的能力。</li>
<li>CFRunLoopTimer：基于事件的定时器，具备和NSTimer免费转换</li>
<li>CFRunLoopObserver：可以通过注册一些observer对runloop进行一些相关时间点的监测和观察。主要监测的时间点有6个：<br><strong>KCFRunLoopEntry</strong> （通知观察者runloop准备启动了）；<br><strong>kCFRunLoopBeforeTimers</strong>（通知观察者runloop将要对一些timer的相关事件进行处理）；<br><strong>kCFRunLoopBeforeSources</strong> (通知观察者runloop将要处理一些source时间)<br><strong>kCFRunLoopBeforeWaiting</strong> (通知观察者runloop即将进入休眠状态，用户态到内核态的切换)<br><strong>kCFRunLoopAfterWaiting</strong> (通知观察者runloop即将从内核态切换为用户态)<br><strong>KCFRunLoopExit</strong> (通知观察者runloop即将退出)</li>
</ul>
<p><strong>一个RunLoop对应若干个Mode，每个Mode对应若干个Observer、Timer、Source。</strong> 不同mode里的事件不会相互影响。也就是说当我们把一个timer、observer、source添加到某一个mode上后，如果当前runloop是运行在另一个runloop下面的话，对应的timer、source、observer事件是不会进行响应的。</p>
<h4 id="Runloop-mode"><a href="#Runloop-mode" class="headerlink" title="Runloop mode"></a>Runloop mode</h4><ul>
<li><p>kCFRunLoopDefaultMode: App的默认Mode，通常主线程在这个mode下运行；</p>
</li>
<li><p>UITrackingRunLoopMode: 界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响；</p>
</li>
<li><p>UIInitializationRunLoopMode: 刚启动App时的Mode，启动完成就不再使用；</p>
</li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部mode，通常用不到；</p>
</li>
<li><p>KCFRunLoopCommonModes: 并不是一个实际存在的mode，其实是同步source、timer、observer到多个mode中的一种技术方案。</p>
</li>
</ul>
<h4 id="RunLoop事件循环机制"><a href="#RunLoop事件循环机制" class="headerlink" title="RunLoop事件循环机制"></a>RunLoop事件循环机制</h4><p><img src="/2019/02/19/RunLoop/runloop.jpeg" alt=""></p>
<p>大概说一下，在runloop开启的时候会发出kCFRunLoopEntry通知，告知即将进去RunLoop。那一启动就相当于进入了用户态的模式，所以优先处理Timer事件，如果有标记过的source0事件那就接着处理source0事件，如果有source1事件（也就是唤醒时收到的消息）那就处理source1事件，如果没有source1事件，那就会发出beforWaiting通知进入休眠状态。在休眠期间如果收到了Timer、source1、外部手动唤醒等事件，则runloop又会被唤醒。</p>
<ul>
<li><p>面试题：从点击APP图标到程序启动、运行、退出。这个过程中系统都发生了什么？</p>
<p>  我们调用了main函数之后，会调用UIApplicationMain这个函数。在这个函数内部会启动主线程的runloop，在经过一系列处理后（timer、source0事件），runloop就会进入休眠状态。而此时如果我们点击屏幕，会产生一个mach_port，基于mach_port会转成source1事件，然后将主线程唤醒。最后杀死程序的时候就会发出KCFRunLoopExit的通知。</p>
</li>
</ul>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="RunLoop-与-NSTimer"><a href="#RunLoop-与-NSTimer" class="headerlink" title="RunLoop 与 NSTimer"></a>RunLoop 与 NSTimer</h4><h5 id="scrollview滑动时，NSTimer不生效问题"><a href="#scrollview滑动时，NSTimer不生效问题" class="headerlink" title="scrollview滑动时，NSTimer不生效问题"></a>scrollview滑动时，NSTimer不生效问题</h5><p>解题思路：正常情况下，scrollview在当前线程(UI主线程)是运行在DefaultMode下的，当发送滑动时，会发生mode的切换，会切换到UITrackingRunLoopMode下。前面讲述到，当我们把一个timer、observer、source添加到某一个mode上后，如果当前runloop是运行在另一个runloop下面的话，对应的timer、source、observer事件是不会进行响应的。而这里，Timer默认添加到DefaultMode下的，所以当切换到TrackingMode之后，Timer就不会再生效了。所以这时commonmodes就起作用了，因为commonmodes可以把timer的事件同步到多个mode中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- RunLoop 与 NSTimer</span><br><span class="line">- (void)begintime &#123;</span><br><span class="line">    _tick = 0;</span><br><span class="line">    NSTimer * timer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(timeTick) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; //如果这里是NSDefaultRunLoopMode，则滚动textview的时候，定时器不会走</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timeTick &#123;</span><br><span class="line">    _tick += 1;</span><br><span class="line">    _timelabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,_tick];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RunLoop-与-多线程"><a href="#RunLoop-与-多线程" class="headerlink" title="RunLoop 与 多线程"></a>RunLoop 与 多线程</h4><h5 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h5><p>解题思路：前文数据结构中可知线程和RunLoop是一一对应的关系；自己创建的线程默认情况下是没有RunLoop的。所以首先我们要为线程开启一个RunLoop，其次向RunLoop中添加一个Port/Source等维持RunLoop的事件循环，最后启动。常驻线程就避免了系统频繁地创建和销毁线程。比如网络请求时，一般需要开辟子线程进行请求，但是不能每个接口都去开辟新的线程，所以开一个常驻线程是最好的处理方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- RunLoop 实现常驻线程</span><br><span class="line">static BOOL runAlways = YES;</span><br><span class="line">- (void)usethread &#123;</span><br><span class="line">    [self performSelector:@selector(subThreadRun) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程安全的方式创建thread</span><br><span class="line">- (NSThread *)thread &#123;</span><br><span class="line">    if (_thread == nil) &#123;</span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            _thread = [[NSThread alloc] initWithTarget:self selector:@selector(runThread) object:nil];</span><br><span class="line">            [_thread setName:@&quot;com.fcf.thread&quot;];</span><br><span class="line">            [_thread start];// 启动</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)runThread &#123;</span><br><span class="line">    //方法一：创建一个可控的runloop</span><br><span class="line">    //创建一个source</span><br><span class="line">    CFRunLoopSourceContext context = &#123;0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL&#125;;</span><br><span class="line">    CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context);</span><br><span class="line"></span><br><span class="line">    //创建runloop，同时向runloop的defaultmode添加source CFRunLoopGetCurrent类似懒加载方法</span><br><span class="line">    CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    while (runAlways) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //将当前runloop运行在kCFRunLoopDefaultMode下</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当runaway为NO时跳出runloop，线程退出</span><br><span class="line">    CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source, kCFRunLoopDefaultMode);</span><br><span class="line">    CFRelease(source);</span><br><span class="line">    </span><br><span class="line">    //方法二：创建一个一直存在的runloop</span><br><span class="line">//    @autoreleasepool &#123;</span><br><span class="line">//        NSRunLoop * runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">//        [runloop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes];</span><br><span class="line">//        NSLog(@&quot;启动RunLoop前--%@&quot;,runloop.currentMode);</span><br><span class="line">//        [runloop run];</span><br><span class="line">//    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) subThreadRun &#123;</span><br><span class="line">    NSLog(@&quot;启动RunLoop后--%@&quot;,[NSRunLoop currentRunLoop].currentMode);</span><br><span class="line">    NSLog(@&quot;%@----子线程任务开始&quot;,[NSThread currentThread]);</span><br><span class="line">    [NSThread sleepForTimeInterval:3.0];</span><br><span class="line">    NSLog(@&quot;%@----子线程任务结束&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/7eaedfc8f8f6" target="_blank" rel="noopener">避免使用 GCD Global队列创建Runloop常驻线程</a></p>
<h4 id="RunLoop-与-UITableView"><a href="#RunLoop-与-UITableView" class="headerlink" title="RunLoop 与 UITableView"></a>RunLoop 与 UITableView</h4><p>通过runloop对UItableview的卡顿进行优化。上文有提到runloop除了保证程序不退出外，它还可以监听消息、定时渲染UI。所以在UITableView滑动时，会触发屏幕UI变化，UI变化会触发Cell的复用和渲染，而如果Cell的渲染耗时太长就会造成在runloop一次迭代之内，CPU和GPU的渲染工作无法完成造成失帧，形成卡顿。</p>
<p>所以解决的机制就是：1、将耗时的任务从主线程剥离，放到runloop进入beforWaiting的休眠状态之后再执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^RunLoopTask)(void);</span><br><span class="line"></span><br><span class="line">@interface TestTableController ()</span><br><span class="line">@property (nonatomic, strong)NSMutableArray * dataSource;</span><br><span class="line">//用来存放任务的数组</span><br><span class="line">@property (nonatomic, strong) NSMutableArray&lt;RunLoopTask&gt; *tasks;</span><br><span class="line">//最大任务数量</span><br><span class="line">@property (nonatomic, assign) NSInteger maxTaskCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestTableController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.title = @&quot;优化TB&quot;;</span><br><span class="line">    _dataSource = [NSMutableArray array];</span><br><span class="line">    _tasks = [NSMutableArray array];</span><br><span class="line">    _maxTaskCount = 27; //一般是初始化cell的个数。</span><br><span class="line">    _useRunloop = YES;</span><br><span class="line">    </span><br><span class="line">    self.tableView.rowHeight = 80;</span><br><span class="line">    self.tableView.tableFooterView = [UIView new];</span><br><span class="line">    </span><br><span class="line">    //添加定时器，使每个时间间隔定时唤醒runloop。</span><br><span class="line">    CADisplayLink * displaylink = [CADisplayLink displayLinkWithTarget:self selector:@selector(timeMethod)];</span><br><span class="line">    [displaylink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [self addRunLoopObserver];</span><br><span class="line">    [self createDate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timeMethod &#123;</span><br><span class="line">    //什么都不做</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)createDate &#123;</span><br><span class="line">    </span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">&#125;</span><br><span class="line">//监听runloop，利用runloop休眠的时机执行耗时task</span><br><span class="line">- (void)addRunLoopObserver &#123;</span><br><span class="line">    /* CFRunLoopAddObserver 注册runloop观察者函数，三个参数分别是currentrunloop、observer、mode</span><br><span class="line">     * CFRunLoopObserverCreateWithHandler 创建观察者函数，kCFRunLoopBeforeWaiting,表示监听runloop即将切到内核态的通知，也可以监听所有通知kCFRunLoopAllActivities。</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //获取当前的runloop</span><br><span class="line">    CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line">    //定义一个context</span><br><span class="line">    CFRunLoopObserverContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)(self),</span><br><span class="line">        &amp;CFRetain,</span><br><span class="line">        &amp;CFRelease,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line">    //定义一个观察者</span><br><span class="line">    static CFRunLoopObserverRef defaultModeObserver;</span><br><span class="line">    //创建观察者</span><br><span class="line">    defaultModeObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                  kCFRunLoopBeforeWaiting,</span><br><span class="line">                                                  YES,</span><br><span class="line">                                                  0,</span><br><span class="line">                                                  &amp;CallBack,</span><br><span class="line">                                                  &amp;context);</span><br><span class="line">    //添加观察者</span><br><span class="line">    CFRunLoopAddObserver(runloop, defaultModeObserver, kCFRunLoopDefaultMode);</span><br><span class="line">    //</span><br><span class="line">    CFRelease(defaultModeObserver);</span><br><span class="line">    </span><br><span class="line">//    //每16.7ms会执行一次</span><br><span class="line">//    __weak typeof(self) weakself = self;</span><br><span class="line">//    CFRunLoopAddObserver(CFRunLoopGetCurrent(), CFRunLoopObserverCreateWithHandler(nil, kCFRunLoopBeforeWaiting, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">//        //</span><br><span class="line">//        if (weakself.tasks.count == 0) &#123;</span><br><span class="line">//            return ;</span><br><span class="line">//        &#125;</span><br><span class="line">//        // 这样每一次都会把所有task都执行一遍</span><br><span class="line">//        while (weakself.tasks.count &gt; 0) &#123;</span><br><span class="line">//            RunLoopTask task = [weakself.tasks objectAtIndex:0];</span><br><span class="line">//            //执行</span><br><span class="line">//            task();</span><br><span class="line">//            //执行完移除</span><br><span class="line">//            [self.tasks removeObjectAtIndex:0];</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;), kCFRunLoopDefaultMode);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 任务单独选择时机执行</span><br><span class="line">static void CallBack(CFRunLoopObserverRef bserver, CFRunLoopActivity activity,void * info) &#123;</span><br><span class="line">    TestTableController * vcself = (__bridge TestTableController *)info;</span><br><span class="line">    if (vcself.tasks.count == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    RunLoopTask task = vcself.tasks.firstObject;</span><br><span class="line">    if (task) &#123;</span><br><span class="line">        task();</span><br><span class="line">    &#125;</span><br><span class="line">    [vcself.tasks removeObjectAtIndex:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加任务到数组</span><br><span class="line">- (void)addTask:(RunLoopTask)task&#123;</span><br><span class="line">    //保存新任务</span><br><span class="line">    [self.tasks addObject:task];</span><br><span class="line">    </span><br><span class="line">    //保证之前没来得及显示的图片不会再绘制</span><br><span class="line">    if (self.tasks.count &gt; _maxTaskCount) &#123;</span><br><span class="line">        [self.tasks removeObjectAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Table view data source</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfSectionsInTab啧啧啧啧啧啧做做做做做做做leView:(UITableView *)tableView &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class="line">    return 300;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    return [self loadCellWithRunLoop:tableView atIndexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)loadCellWithRunLoop:(UITableView *)tableView atIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    ImgsCell *cell = [ImgsCell cellWithTableView:tableView];</span><br><span class="line">    cell.img1.image = nil;</span><br><span class="line">    cell.img2.image = nil;</span><br><span class="line">    cell.img3.image = nil;</span><br><span class="line">    __weak typeof(self) weakself = self;</span><br><span class="line">    [self addTask:^&#123;</span><br><span class="line">        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;01&quot; ofType:@&quot;jpg&quot;];</span><br><span class="line">        UIImage *img = [UIImage imageWithContentsOfFile:path];</span><br><span class="line">        cell.img1.image = img;</span><br><span class="line">    &#125;];</span><br><span class="line">    [self addTask:^&#123;</span><br><span class="line">        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;02&quot; ofType:@&quot;jpg&quot;];</span><br><span class="line">        UIImage *img = [UIImage imageWithContentsOfFile:path];</span><br><span class="line">        cell.img2.image = img;</span><br><span class="line">    &#125;];</span><br><span class="line">    [self addTask:^&#123;</span><br><span class="line">        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;03&quot; ofType:@&quot;jpg&quot;];</span><br><span class="line">        UIImage *img = [UIImage imageWithContentsOfFile:path];</span><br><span class="line">        cell.img3.image = img;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>问题：虽然网上大部分教程的runloop优化tableview的操作都与此类似。但是还存在几个问题：<br>1、首屏渲染的问题。如果进到demo不进行拖动的话，首屏是不会自动渲染的。所以我就把添加最新任务的代码改成了下面这样。但是这样也会导致新的问题，因为tasks存储的不是最新的任务，所以当滑动停止时，屏幕上需要渲染的任务和tasks里的任务可能不是一一对应的，这就导致了有的img没有被渲染出来的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//添加任务到数组</span><br><span class="line">- (void)addTask:(RunLoopTask)task&#123;</span><br><span class="line">    //保存新任务</span><br><span class="line">    if (self.tasks.count &lt; _maxTaskCount) &#123;</span><br><span class="line">        [self.tasks addObject:task];</span><br><span class="line">    &#125;</span><br><span class="line">//    [self.tasks addObject:task];</span><br><span class="line">//</span><br><span class="line">//    //保证之前没来得及显示的图片不会再绘制</span><br><span class="line">//    if (self.tasks.count &gt; _maxTaskCount) &#123;</span><br><span class="line">//        [self.tasks removeObjectAtIndex:0];</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、如果将观察者里的kCFRunLoopDefaultMode改成NSRunLoopCommonModes（目的是为了一边滑动也可以一边渲染）,当资源img不止是当前那3张图片时，页面会出现明显的卡顿现象！<br>(如果有哪位大神解决了上述问题，还请告知)</p>
<h4 id="RunLoop-监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来"><a href="#RunLoop-监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来" class="headerlink" title="RunLoop 监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来"></a>RunLoop 监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来</h4><p>根据上面RunLoop事件循环的img，我们可以看到，主线程在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间耗时的时长是检测主线程是否卡顿的一个方式。如果这个耗时大于某个阈值，则会存在卡顿。所以检测卡顿就可以在这两个状态下监听耗时，如果存在卡顿则把线程堆栈记录下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CheckBlockManager.h&quot;</span><br><span class="line">#import &lt;CrashReporter/CrashReporter.h&gt; //打印crash的第三方framework</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 往主线程runloop添加observer，以监听主线程的runloop周期变化</span><br><span class="line"> * 往子线程添加定时器，以每隔一段时间检测耗时时长</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@interface CheckBlockManager()</span><br><span class="line">@property (nonatomic, strong) NSThread                  *monitorThread; //监控线程</span><br><span class="line">@property (nonatomic, assign) CFRunLoopObserverRef      observer;//观察者</span><br><span class="line">@property (nonatomic, assign) CFRunLoopTimerRef         timer; //定时器</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSDate                    *startDate; //开始执行时间</span><br><span class="line">@property (nonatomic, assign) BOOL                      excuting; //执行时长</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSTimeInterval            interval; //定时器间隔时长</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval            fault;    //卡顿阈值</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CheckBlockManager</span><br><span class="line"></span><br><span class="line">static CheckBlockManager * _instance = nil;</span><br><span class="line">+(instancetype)shareInstance &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [CheckBlockManager new];</span><br><span class="line">        _instance.monitorThread = [[NSThread alloc] initWithTarget:self selector:@selector(monitorThreadEntryPoint) object:nil];</span><br><span class="line">        </span><br><span class="line">        [_instance.monitorThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)monitorThreadEntryPoint &#123;</span><br><span class="line">    //开启常驻线程</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;CheckBlockManager&quot;];</span><br><span class="line">        NSRunLoop * runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runloop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始监控</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    [self startWithInterval:1.0 fault:2.0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 往主线程runloop添加observer，以监听主线程的runloop周期变化</span><br><span class="line">//开始监听 interval：定时器间隔时长  fault：卡顿阈值</span><br><span class="line">- (void)startWithInterval:(NSTimeInterval)interval fault:(NSTimeInterval)fault &#123;</span><br><span class="line">    _interval = interval;</span><br><span class="line">    _fault = fault;</span><br><span class="line">    </span><br><span class="line">    if (_observer) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)(self),</span><br><span class="line">        NULL,</span><br><span class="line">        NULL,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                        kCFRunLoopAllActivities,</span><br><span class="line">                                        YES,</span><br><span class="line">                                        0,</span><br><span class="line">                                        &amp;runloopCallBack,</span><br><span class="line">                                        &amp;context);</span><br><span class="line">    </span><br><span class="line">    //将obverse添加到主线程的runloop中</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    //创建timer，并添加到子线程的runloop中</span><br><span class="line">    [self performSelector:@selector(addTimerToMonitorThread) onThread:self.monitorThread withObject:nil waitUntilDone:NO modes:@[NSRunLoopCommonModes]];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 往子线程添加定时器，以每隔一段时间检测耗时时长</span><br><span class="line">- (void)addTimerToMonitorThread &#123;</span><br><span class="line">    if (_timer) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建timer</span><br><span class="line">    CFRunLoopRef currentRunLoop = CFRunLoopGetCurrent();</span><br><span class="line">    CFRunLoopTimerContext context = &#123;0,(__bridge void*)self,NULL,NULL,NULL&#125;;</span><br><span class="line">    _timer = CFRunLoopTimerCreate(kCFAllocatorDefault,</span><br><span class="line">                                  0.1,</span><br><span class="line">                                  _interval,</span><br><span class="line">                                  0,</span><br><span class="line">                                  0,</span><br><span class="line">                                  &amp;runloopTimerCallBack,</span><br><span class="line">                                  &amp;context);</span><br><span class="line">    CFRunLoopAddTimer(currentRunLoop, _timer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeTimer &#123;</span><br><span class="line">    if (_timer) &#123;</span><br><span class="line">        CFRunLoopRef currentRunLoop = CFRunLoopGetCurrent();</span><br><span class="line">        CFRunLoopRemoveTimer(currentRunLoop, _timer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(_timer);</span><br><span class="line">        _timer = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stop &#123;</span><br><span class="line">    if (_observer) &#123;</span><br><span class="line">        CFRunLoopRemoveObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(_observer);</span><br><span class="line">        _observer = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    [self performSelector:@selector(removeTimer) onThread:self.monitorThread withObject:nil waitUntilDone:NO modes:@[NSRunLoopCommonModes]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用第三方打印卡顿信息</span><br><span class="line">- (void)handleStackInfo &#123;</span><br><span class="line">    //打印</span><br><span class="line">    NSData * lagData = [[[PLCrashReporter alloc] initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];</span><br><span class="line">    PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];</span><br><span class="line">    NSString * lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">    NSLog(@&quot;%@&quot;,lagReportString);</span><br><span class="line">&#125;</span><br><span class="line">//监听runloop</span><br><span class="line">static void runloopCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    CheckBlockManager * monitor = (__bridge CheckBlockManager*)info;</span><br><span class="line">    NSLog(@&quot;mainrunloop --- %@&quot;,[NSThread currentThread]);</span><br><span class="line">    switch (activity) &#123;</span><br><span class="line">        case kCFRunLoopEntry:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopEntry&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeTimers:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeTimers&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeSources:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeSources&quot;);</span><br><span class="line">            monitor.startDate = [NSDate date];</span><br><span class="line">            monitor.excuting = YES;</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopBeforeWaiting:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;);</span><br><span class="line">            monitor.excuting = NO;</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopAfterWaiting:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopAfterWaiting&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case kCFRunLoopExit:</span><br><span class="line">            NSLog(@&quot;kCFRunLoopExit&quot;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听timer</span><br><span class="line">static void runloopTimerCallBack(CFRunLoopTimerRef timer, void *info) &#123;</span><br><span class="line">    CheckBlockManager * monitor = (__bridge CheckBlockManager*)info;</span><br><span class="line">    if (!monitor.excuting) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果主线程正在执行任务，并且这一次loop执行到现在还没执行完，那就需要计算时间差</span><br><span class="line">    NSTimeInterval excuteTime = [[NSDate date] timeIntervalSinceDate:monitor.startDate];</span><br><span class="line">    NSLog(@&quot;定时器 -- %@&quot;,[NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;主线程执行了-- %f s&quot;,excuteTime);</span><br><span class="line">    if (excuteTime &gt;= monitor.fault) &#123;</span><br><span class="line">        NSLog(@&quot;线程卡顿了%f秒&quot;,excuteTime);</span><br><span class="line">        [monitor handleStackInfo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="RunLoop-让应用“起死回生”"><a href="#RunLoop-让应用“起死回生”" class="headerlink" title="RunLoop 让应用“起死回生”"></a>RunLoop 让应用“起死回生”</h4><p>应用起死回生就不再赘述了，因为结果也只是防止第一次崩溃而已。有兴趣可以去看这个大神的文章<br><a href="https://blog.csdn.net/u011619283/article/details/53673255" target="_blank" rel="noopener">让应用起死回生</a></p>
<p><a href="https://github.com/FCF5646448/iOSAdvanceSet" target="_blank" rel="noopener">github</a></p>
<p>如果您喜欢或者觉得有帮助请给个小❤️❤️吧！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/runloop/" rel="tag"># runloop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/23/Runtime/" rel="next" title="Runtime">
                <i class="fa fa-chevron-left"></i> Runtime
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/19/multithreads/" rel="prev" title="multithreads">
                multithreads <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">FengCaifan</p>
              <p class="site-description motion-element" itemprop="description">记录成长，记录生活</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论"><span class="nav-number">1.</span> <span class="nav-text">理论</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自我理解"><span class="nav-number">1.1.</span> <span class="nav-text">自我理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop的作用："><span class="nav-number">1.2.</span> <span class="nav-text">RunLoop的作用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop的数据结构"><span class="nav-number">1.3.</span> <span class="nav-text">RunLoop的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runloop-mode"><span class="nav-number">1.4.</span> <span class="nav-text">Runloop mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop事件循环机制"><span class="nav-number">1.5.</span> <span class="nav-text">RunLoop事件循环机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实战"><span class="nav-number">2.</span> <span class="nav-text">实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-与-NSTimer"><span class="nav-number">2.1.</span> <span class="nav-text">RunLoop 与 NSTimer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#scrollview滑动时，NSTimer不生效问题"><span class="nav-number">2.1.1.</span> <span class="nav-text">scrollview滑动时，NSTimer不生效问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-与-多线程"><span class="nav-number">2.2.</span> <span class="nav-text">RunLoop 与 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何实现一个常驻线程"><span class="nav-number">2.2.1.</span> <span class="nav-text">如何实现一个常驻线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-与-UITableView"><span class="nav-number">2.3.</span> <span class="nav-text">RunLoop 与 UITableView</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来"><span class="nav-number">2.4.</span> <span class="nav-text">RunLoop 监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RunLoop-让应用“起死回生”"><span class="nav-number">2.5.</span> <span class="nav-text">RunLoop 让应用“起死回生”</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FengCaifan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
